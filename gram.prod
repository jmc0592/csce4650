/*
 * productions
 */
%start statement_list

%%
statement_list  :   statement_list statement
                |   statement
                ;

statement   :   ID '=' expression ';'
        {
            generate_expression($1->current->key.c_str(), $3);
            printf("[Parser]:ID = expression;\n");
        }
        |   OUTPUT '(' ID ')' ';'
        {
            printf("[Parser]:output()\n");
            generate_output($3->current->key.c_str());
        }
        |   BEG ';'
        {
            printf("[Parser]:Found 'begin' token\n");
        }
        |   END ';'
        {
            printf("[Parser]:Found 'end' token'\n");
        }
    ;

expression : expression add_op term 
        {
            printf("[Parser]:expression add_op term\n");
            printf("[Parser]:%s %s %s;\n", $1,$2,$3);
        }
        | term
        {
            //$$ = $1;
            printf("[Parser]:We've seen an ID starting an expression\n"); 
        }
   ;

term    :   term mul_op factor
        {
            printf("[Parser]:term mul_op factor\n");
            printf("[Parser]:%s %s %s;\n", $1,$2,$3);
        }
        | factor
        {
            //$$ = $1;
            printf("[Parser]:Single factor\n");
        }
    ;

factor  :   factor EXPONENT atom
        {
            printf("[Parser]:factor EXPONENT atom\n");
            printf("[Parser]:%s ** %s;\n", $1,$3);
            tempS = generate_exponentiation($1, $3);
            //$$ = tempS;
            printf("Exponent register is %s\n", tempS);
        }
        | atom
        {
            //$$ = $1;
            printf("[Parser]:atom\n");
        }
    ;

atom    :   ID
        {
            $$ = strdup($1->current->key.c_str());
            printf("[Parser]:ID = %s\n", strdup($1->current->key.c_str()));
        }
        |   INTLITERAL
        {
            tempS = (char*)malloc(sizeof(char)*50);
            sprintf(tempS,"%d",$1);
            $$ = tempS;
            printf("[Parser]:INTLITERAL is %d\n",$1);
        }
        |   '(' expression ')'
        {
            printf("[Parser]:(expression)\n");
        }
    ;

add_op  :   '+' {$$ = "+";}
        |   '-' {$$ = "-";}
        ;

mul_op :   '*' {$$ = "*";}
        |   '/'{$$ = "/";}
        ;
%%

/* For basic assignment. 
 * Should produce something like:
 *      '%s = %d\n'
 */
void generate_expression(const char *str, int value)
{
    /*  write a statment of the form 
        
        x = 17;   
    */
    printf("r%d = %d----------;\n", registerNumber, value);
    registerNumber++;
}

void generate_expression(const char *str, char *rhs)
{
    printf("r%d = %s;\n", registerNumber, rhs);
    registerNumber++;
}

/*
 * handles register assignment and logic for exponentiation
 */
char * generate_exponentiation(char *base, char *exponent)
{
    int temp1,temp2,temp3;//for remembering registers
    char tempStr[50];
    char returnReg[50];
    strcpy(returnReg,"r");

    //exponent register
    //if(checkIfVarIsRegister(exponent) == 0) {
        printf("r%d = %s;\n", registerNumber, exponent);
        temp1 = registerNumber;
        registerNumber++;
    //}

    //base register
    printf("r%d = %s;\n", registerNumber, base);
    temp2 = registerNumber;
    registerNumber++;

    //constant multiplier
    printf("r%d = 1;\n", registerNumber);
    temp3 = registerNumber;
    registerNumber++;

    printf("\nExpo:\n");
    printf("\tr%d = r%d * r%d;\n", temp3, temp2, temp3);
    printf("\tr%d = r%d - 1;\n", temp1, temp1);
    printf("\tif(r%d>0) goto Expo;\n", temp1);

    sprintf(tempStr,"%d",temp3);//convert from int to string

    strncat(returnReg,tempStr,strlen(tempStr));

    return returnReg;

}

void generate_output(const char *var)
{
    char temp[50] = "printf(\"%%s\",";
    strcat(temp,var);
    strcat(temp,");");
    printf(temp);
    printf("\n");
}

/*int checkIfVarIsRegister(char *s)
{
    regex_t regex;
    int reti;

    reti = regcomp(&regex, "^[0-9]+",REG_EXTENDED);
    if (reti) {
        fprintf(stderr, "Could not compile regex\n");
        exit(1);
    }
    reti = regexec(&regex, s, 0, NULL, 0);
    if(!reti) {
        printf("[Parser]:var is int\n");
        return 0;
    } else if(reti == REG_NOMATCH) {
        printf("[Parser]:var is register\n");
        return 1;
    }

    regfree(&regex);
}*/

void yyerror(const char *s)
{
        fflush(stdout);
        printf("Syntax Error: %s\n",s);
}