/*
 * productions
 */
%start statement_list

%%
statement_list  :   statement_list statement
                |   statement
                ;

statement   :   ID '=' expression ';'
        {
            generate_expression($1->current->key.c_str(), $3);
            printf("[Parser]:ID = expression;\n");
        }
        |   OUTPUT '(' ID ')' ';'
        {
            printf("[Parser]:output()\n");
        }
        |   BEG ';'
        {
            printf("[Parser]:Found 'begin' token\n");
        }
        |   END ';'
        {
            printf("[Parser]:Found 'end' token'\n");
        }
    ;

expression : expression add_op term 
        {
            printf("[Parser]:expression add_op term\n");
            printf("[Parser]:%s %s %s;\n", $1,$2,$3);
        }
        | term
        {
            //$$ = $1;
            printf("[Parser]:We've seen an ID starting an expression\n"); 
        }
   ;

term    :   term mul_op factor
        {
            printf("[Parser]:term mul_op factor\n");
            printf("[Parser]:%s %s %s;\n", $1,$2,$3);
        }
        | factor
        {
            //$$ = $1;
            printf("[Parser]:Single factor\n");
        }
    ;

factor  :   factor EXPONENT atom
        {
            printf("[Parser]:factor EXPONENT atom\n");
            printf("[Parser]:%s ** %s;\n", $1,$3);
            generate_exponentiation($1, $3);
        }
        | atom
        {
            //$$ = $1;
            printf("[Parser]:atom\n");
        }
    ;

atom    :   ID
        {
            $$ = strdup($1->current->key.c_str());
            printf("[Parser]:ID = %s\n", strdup($1->current->key.c_str()));
        }
        |   INTLITERAL
        {
            sprintf(tempS,"%d",$1);
            $$ = tempS;
            printf("[Parser]:INTLITERAL is %d\n",$1);
        }
        |   '(' expression ')'
        {
            printf("[Parser]:(expression)\n");
        }
    ;

add_op  :   '+' {$$ = "+";}
        |   '-' {$$ = "-";}
        ;

mul_op :   '*' {$$ = "*";}
        |   '/'{$$ = "/";}
        ;
%%

/* For basic assignment. 
 * Should produce something like:
 *      '%s = %d\n'
 */
void generate_expression(const char *str, int value)
{
    /*  write a statment of the form 
        
        x = 17;   
    */
    printf("r%d = %d;\n", registerNumber, value);
    registerNumber++;
}

void generate_expression(const char *str, char *rhs)
{
    printf("r%d = %s;\n", registerNumber, rhs);
    registerNumber++;
}

void generate_exponentiation(char *base, char *exponent)
{
    int temp1,temp2,temp3;
    printf("--doing exponent generation--\n");
    printf("r%d = %s;\n", registerNumber, exponent);
    temp1 = registerNumber;
    registerNumber++;
    printf("r%d = %s;\n", registerNumber, base);
    temp2 = registerNumber;
    registerNumber++;
    printf("r%d = 1;\n", registerNumber);//constant multiplier
    temp3 = registerNumber;
    registerNumber++;
    printf("L1:\n");
    printf("\tr%d = r%d * r%d;\n", temp3, temp2, temp3);
    printf("\tr%d = r%d - 1;\n", temp1, temp1);
    printf("\tbgt L1;\n");

}

void yyerror(const char *s)
{
        fflush(stdout);
        printf("Syntax Error: %s\n",s);
}