/*
 * productions
 */

%start statement_list

%%
statement_list  :   statement_list statement
                |   statement
                ;

statement   :   ID '=' expression ';'
        {
            generate_expression($1->current->key.c_str(), $3);
            //printf("[Parser]:ID = expression;\n");
        }
        |   OUTPUT '(' ID ')' ';'
        {
            //printf("[Parser]:output()\n");
        }
        |   BEG ';'
        {
            //printf("[Parser]:Found 'begin' token\n");
        }
        |   END ';'
        {
            //printf("[Parser]:Found 'end' token'\n");
        }
    ;

expression : expression add_op term 
        {
            //printf("[Parser]:expression add_op term\n");
            //printf("[Parser]:%s %s %s;\n", $1,$2,$3);
            //uh = (char *)malloc(sizeof(char));
            if(uh != "a"){
                //printf("not NULL\n");
                sprintf(uh, "r%d", generate_temp_expression($1, $2, uh));
                //printf("%s\n", uh);
            }
            else{
                uh = (char *)malloc(sizeof(char));
                //printf("IS NULL\n");
                sprintf(uh, "r%d", generate_temp_expression($1, $2, $3));
                //printf("%s\n", uh);
            }
        }
        | term
        {
            //$$ = $1;
            //printf("[Parser]:We've seen an ID starting an expression\n"); 
        }
   ;

term    :   term mul_op factor
        {
            //printf("[Parser]:term mul_op factor\n");
            //printf("[Parser]:%s %s %s;\n", $1,$2,$3);
            //uh = (char *)malloc(sizeof(char));
            if(uh != NULL){
                //printf("not NULL\n");
                sprintf(uh, "r%d", generate_temp_expression($1, $2, uh));
                //printf("%s\n", uh);
            }
            else{
                uh = (char *)malloc(sizeof(char));
                //printf("IS NULL\n");
                sprintf(uh, "r%d", generate_temp_expression($1, $2, $3));
                //printf("%s\n", uh);
            }
        }
        | factor
        {
            //$$ = $1;
            //printf("[Parser]:Single factor\n");
        }
    ;

factor  :   factor EXPONENT atom
        {
            //printf("[Parser]:factor EXPONENT atom\n");
            //printf("[Parser]:%s ** %s;\n", $1,$3);
            generate_exponentiation($1, $3);
        }
        | atom
        {
            //$$ = $1;
           // printf("[Parser]:atom\n");
        }
    ;

atom    :   ID
        {
            $$ = strdup($1->current->key.c_str());
            //printf("[Parser]:ID = %s\n", strdup($1->current->key.c_str()));
        }
        |   INTLITERAL
        {
            sprintf(tempS,"%d",$1);
            $$ = tempS;
            //printf("[Parser]:INTLITERAL is %d\n",$1);
        }
        |   '(' expression ')'
        {
            //printf("[Parser]:(expression)\n");
        }
    ;

add_op  :   '+' {$$ = "+";}
        |   '-' {$$ = "-";}
        ;

mul_op :   '*' {$$ = "*";}
        |   '/'{$$ = "/";}
        ;
%%

/* For basic assignment. 
 * Should produce something like:
 *      '%s = %d\n'
 */
int generate_temp_expression(char *a, char *b, char *c)
{
    /*  write a statment of the form 
        
        x = 17;   
    */
    //printf("FEEDING IN:::::%s, %s, %s\n", a, b, c);
    if(searchRegisters(a) != -1){
        //printf("HERE IS THE THINKY FOR searchRegisters: %d\n", searchRegisters(a));
        sprintf(a, "r%d", searchRegisters(a));
    }
    /*if(searchRegisters(b) != -1){
        //printf("HERE IS THE THINKY FOR searchRegisters: %d\n", searchRegisters(a));
        sprintf(b, "r%d", searchRegisters(b));
    }*/
        //printf ("is it getting down here: %d\n",searchRegisters(c));
    if(searchRegisters(c) != -1){
        //printf("its in the second if");
        sprintf(c, "r%d", searchRegisters(c));
    }
    printf("[FINAL OUTPUT]:r%d = %s %s %s;\n", registerNumber, a, b, c);
    registerNumber++;
    //printingThings();
    //searchRegisters(a);
    return (registerNumber-1);
}

void generate_expression(const char *str, char *rhs)
{
    printf("[FINAL OUTPUT]:r%d = %s;\n", registerNumber, rhs);
    tempR[registerNumber] = (char)str[0];
    registerNumber++;
    //printingThings();
    searchRegisters(str);
}

void generate_exponentiation(char *base, char *exponent)
{
    int temp1,temp2,temp3;
    printf("--doing exponent generation--\n");
    printf("r%d = %s;\n", registerNumber, exponent);
    temp1 = registerNumber;
    registerNumber++;
    printf("r%d = %s;\n", registerNumber, base);
    temp2 = registerNumber;
    registerNumber++;
    printf("r%d = 1;\n", registerNumber);//constant multiplier
    temp3 = registerNumber;
    registerNumber++;
    printf("L1:\n");
    printf("\tr%d = r%d * r%d;\n", temp3, temp2, temp3);
    printf("\tr%d = r%d - 1;\n", temp1, temp1);
    printf("\tbgt L1;\n");

}

void printingThings(){
    for(int i = 0; i<=registerNumber; i++){
        printf("%c ", tempR[i]);
    }
}
int searchRegisters(const char *target){
    for(int x = 0; x<=registerNumber; x++){
        char temp = tempR[x];
        char temp2 = (char)target[0];
        if(temp == temp2){
            //printf("IT IS HERE: %c\n", (char)target[0]);
            return x;
        }
        else{
            //printf("ITS NOT FOUND YO\n");
        }
    }
    return -1;
}
void yyerror(const char *s)
{
        fflush(stdout);
        printf("Syntax Error: %s\n",s);
}