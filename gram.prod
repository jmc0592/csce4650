/*
 * gram.prod
 * NAME is taking place of what was previously ID. 
 */
%start program


%%
program:    dec_list func_list
    ;

func_list:   func
            |   func func_list
    ;

func:   NAME '(' parm_list ')' ':' type {printf("[Parser][func]: push new STL\n"); stackCopy->push();} dec_list s_block
        {
            printf("[Parser][func]: pop new STL\n");
            stackCopy->pop();
        }
    ;

parm_list:   NAME
            |   NAME ',' parm_list
            |
    ;               /* goes to "nothing", i.expression. empty string */ 

dec_list:   decl
            | decl ';' dec_list
            |  /* goes to "nothing", i.expression. empty string */
    ;         
decl:   type NAME
        {
            stackCopy->curr->symbolRecord.current->setType(strdup($1));
            stackCopy->curr->symbolRecord.current->setOffset(g_offSet);
            printf("[Parser][decl]: '%s' inserted. type = %s and offset = %d to stack\n", strdup($2->current->key.c_str()), strdup($1), g_offSet);
            
            updateOffSet(strdup($1));
        }
        |   type NAME '['size_list']'
        {
            calcArrayOffSet(strdup($1));
            printf("[Parser][decl]: sizeList list contains ... \n");
            for(list<int>::iterator list_iter = g_sizeList.begin(); list_iter != g_sizeList.end(); list_iter++)
            {
                cout << *list_iter << endl;
            }
            printf("[Parser][decl]: array '%s' inserted. type = %s and offset = %d to stack\n", strdup($2->current->key.c_str()),strdup($1), g_offSet);
        }
    ;

size_list:  INTLITERAL
            {
                g_sizeList.push_front($1);
            }
            |   INTLITERAL ',' size_list
            {
                g_sizeList.push_front($1);
            }
    ;

type:   INT
        {
            $$ = strdup($1);
        }
        |   CHAR
        {
            $$ = strdup($1);
        }
        |   BOOL
        {
            $$ = strdup($1);
        }
        |   VOID
        {
            $$ = strdup($1);
        }
    ;

s_block: BEG {printf("[Parser][s_block]: push new STL\n"); stackCopy->push();} dec_list stmts END
        {
            printf("[Parser][s_block]: pop new STL\n");
            stackCopy->pop();
        }
    ;

stmts:  statement
        |   statement stmts
    ;

statement:  id '=' expression
            {
                printf("[Parser][statement]: id = expression;\n");                
                generate_expression($1, $3);
            }
            |   NAME '(' expr_list ')'
            |   id '=' conditional_expr
            |   IF '(' conditional_expr ')' s_block
            {
                printf("[Parser][statement]: if found. counter = %d\n", g_ifCounter);
                g_ifCounter++;
            }
            |   IF '(' conditional_expr ')' s_block ELSE s_block
            {
                printf("[Parser][statement]: if found. counter = %d\n", g_ifCounter);
                g_ifCounter++;                
            }
            |   DO INTLITERAL NAME '=' do_list stmts end_do
            {
                printf("[Parser][statement]: loop found. counter = %d\n", g_loopCounter);
                g_loopCounter++;

            }
            |   RETURN primary
            |   QUIT
    ;

end_do:  INTLITERAL CONTINUE
    ;

conditional_expr:    expression rel_op expression
                    |   NOT '(' conditional_expr ')'
                    |   conditional_expr AND '(' conditional_expr ')'
                    |   conditional_expr AND expression rel_op expression
                    |   conditional_expr OR '(' conditional_expr ')'
                    |   conditional_expr OR expression rel_op expression
    ;

do_list: expression ',' expression
        |   expression ',' expression ',' expression
    ;

expr_list:   expression
            |   expression ',' expr_list
            |   /* goes to "nothing", i.expression. empty string */ 
    ;

expression:  expression bop bit_term
    |   bit_term
    ;

bit_term:    bit_term shift_op shift_term
            |   shift_term
    ;

shift_term:  shift_term add_op term
            |   term
    ;

term:   term mul_op factor
        |   factor
    ;

factor: factor EXPONENT u_operand
        |   u_operand
    ;

u_operand:   uop primary
            |   primary
    ;

primary:    id
            |   NAME '(' expr_list ')'   
            |   '(' expression ')'
            |   INTLITERAL		/* could be any integer number */
            |   STRINGLITERAL	/* any quoted string, like "ET phone home" */
    ;

id: NAME
    {
        $$ = strdup($1->current->key.c_str());
    }
    |   NAME '[' expr_list ']' 
    {
        $$ = strdup($1->current->key.c_str());
    }
    ;

rel_op:  GT
        |   GE
        |   LE
        |   LT
        |   EQ
        |   NEQ
    ;

bop:    '&'
        |   '|'
        |   '^'
    ;

shift_op:    "<<"
            |   ">>"
    ;

mul_op:  '*'
        |   '/'
        |   '%'
    ;

add_op:  '+'
        |   '-'
    ;

uop:    '-'
        |   "++"
        |   "--"
        |   '&'
        |   '~'
    ;
%%

void calcArrayOffSet(char *type)
{
    list<int> rowMajor;
    int temp;

    if(strcmp(type, "int") == 0) {
        rowMajor.push_front(4);
    }
    else {
        rowMajor.push_front(1);
    }

    for(list<int>::iterator list_iter = g_sizeList.begin(); list_iter != g_sizeList.end(); list_iter++)
    {
        temp = (*list_iter) * rowMajor.front();
        rowMajor.push_front(temp);
        cout << *list_iter << endl;
        cout << rowMajor.front() << endl;
    }

    rowMajor.pop_front();//ugly fix for removing unneeded elemnent
}
void updateOffSet(char *type)
{
    if(strcmp(type, "int") == 0) {
        g_offSet = g_offSet + 4;//4 bytes for an int
    } else {
        g_offSet = g_offSet + 1;//1 bytes for a char
    }
}
int searchRegisters(const char *target){
    for(int x = 0; x<=registerNumber; x++){
        char temp = tempR[x];
        char temp2 = (char)target[0];
        if(temp == temp2){
            //printf("IT IS HERE: %c\n", (char)target[0]);
            return x;
        }
        else{
            //printf("ITS NOT FOUND YO\n");
        }
    }
    return -1;
}

void generate_expression(const char *str, char *rhs)
{
    if(searchRegisters(rhs) != -1){
        printf("r%d = r%d;\n", registerNumber, searchRegisters(rhs));
        tempR[registerNumber] = (char)str[0];
        registerNumber++;
        //printingThings();
        searchRegisters(str);
    }
    else{
        printf("r%d = %s;\n", registerNumber, rhs);
        tempR[registerNumber] = (char)str[0];
        registerNumber++;
        //printingThings();
        searchRegisters(str);
    }
}

void yyerror(const char *s)
{
        fflush(stdout);
        printf("Syntax Error: %s\n",s);
}