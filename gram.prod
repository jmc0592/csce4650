/*
 * gram.prod
 * NAME is taking place of what previously ID. 
 */
%start program


%%
program:    dec_list func_list
    ;

func_list:   func
            |   func func_list
    ;

func:   NAME '(' parm_list ')' ':' type {printf("[Parser][func]: push new STL\n"); stackCopy->push();} dec_list s_block
        {
            stackCopy->pop();
        }
    ;

parm_list:   NAME
            |   NAME ',' parm_list
            |
    ;               /* goes to "nothing", i.expression. empty string */ 

dec_list:   decl
            | decl ';' dec_list
            |  /* goes to "nothing", i.expression. empty string */
    ;         
decl:   type NAME
        {
            stackCopy->curr->symbolRecord.current->setType(strdup($1));
            stackCopy->curr->symbolRecord.current->setOffset(g_offSet);
            printf("[Parser][decl]: '%s' inserted type and offset to stack\n", strdup($2->current->key.c_str()));
            if(strcmp(strdup($1), "int") == 0) {
                g_offSet = g_offSet + 4;//4 bytes for an int
            } else {
                g_offSet = g_offSet + 1;//1 bytes for a char
            }
        }
        |   type NAME '['size_list']'
        {

        }
    ;

size_list:   INTLITERAL
            |   INTLITERAL ',' size_list
    ;

type:   INT
        {
            $$ = strdup($1);
        }
        |   CHAR
        {
            $$ = strdup($1);
        }
        |   BOOL
        {
            $$ = strdup($1);
        }
        |   VOID
        {
            $$ = strdup($1);
        }
    ;

s_block: BEG {printf("[Parser][s_block]: push new STL\n"); stackCopy->push();} dec_list stmts END
        {
            stackCopy->pop();
        }
    ;

stmts:  statement
        |   statement stmts
    ;

statement:  id '=' expression
    |   NAME '(' expr_list ')'
    |   id '=' conditional_expr
    |   IF '(' conditional_expr ')' s_block
    |   IF '(' conditional_expr ')' s_block ELSE s_block
    |   DO INTLITERAL NAME '=' do_list stmts end_do
    |   RETURN primary
    |   QUIT
    ;

end_do:  INTLITERAL CONTINUE
    ;

conditional_expr:    expression rel_op expression
                    |   NOT '(' conditional_expr ')'
                    |   conditional_expr AND '(' conditional_expr ')'
                    |   conditional_expr AND expression rel_op expression
                    |   conditional_expr OR '(' conditional_expr ')'
                    |   conditional_expr OR expression rel_op expression
    ;

do_list: expression ',' expression
        |   expression ',' expression ',' expression
    ;

expr_list:   expression
            |   expression ',' expr_list
            |   /* goes to "nothing", i.expression. empty string */ 
    ;

expression:  expression bop bit_term
    |   bit_term
    ;

bit_term:    bit_term shift_op shift_term
            |   shift_term
    ;

shift_term:  shift_term add_op term
            |   term
    ;

term:   term mul_op factor
        |   factor
    ;

factor: factor EXPONENT u_operand
        |   u_operand
    ;

u_operand:   uop primary
            |   primary
    ;

primary:    id
            |   NAME '(' expr_list ')'   
            |   '(' expression ')'
            |   INTLITERAL		/* could be any integer number */
            |   STRINGLITERAL	/* any quoted string, like "ET phone home" */
    ;

id: NAME
    |   NAME '[' expr_list ']' 
    ;

rel_op:  GT
        |   GE
        |   LE
        |   LT
        |   EQ
        |   NEQ
    ;

bop:    '&'
        |   '|'
        |   '^'
    ;

shift_op:    "<<"
            |   ">>"
    ;

mul_op:  '*'
        |   '/'
        |   '%'
    ;

add_op:  '+'
        |   '-'
    ;

uop:    '-'
        |   "++"
        |   "--"
        |   '&'
        |   '~'
    ;
%%

void yyerror(const char *s)
{
        fflush(stdout);
        printf("Syntax Error: %s\n",s);
}